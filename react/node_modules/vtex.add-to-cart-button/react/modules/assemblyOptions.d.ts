import type { ProductTypes } from 'vtex.product-context';
declare type GroupId = string;
declare type GroupTypes = 'SINGLE' | 'TOGGLE' | 'MULTIPLE';
declare type InputValue = Record<string, string | boolean>;
export interface AssemblyOptions {
    items: Record<GroupId, ProductTypes.AssemblyOptionItem[]>;
    inputValues: Record<GroupId, InputValue>;
    areGroupsValid: Record<string, boolean>;
}
export declare type Option = ItemOption;
export interface ItemOption {
    assemblyId: string;
    id?: string;
    quantity?: number;
    seller?: string;
    options?: Option[];
    inputValues?: InputValue;
}
interface AddedItem {
    id: string;
    name: string;
    quantity: number;
    sellingPrice: number;
    sellingPriceWithAssemblies: number;
    assemblyOptions?: ParsedAssemblyOptionsMeta;
}
interface CartAddedOption {
    normalizedQuantity: number;
    extraQuantity: number;
    choiceType: GroupTypes;
    item: AddedItem;
}
interface CartRemovedOption {
    name: string;
    initialQuantity: number;
    removedQuantity: number;
}
export interface ParsedAssemblyOptionsMeta {
    added: CartAddedOption[];
    removed: CartRemovedOption[];
    parentPrice: number;
}
interface ParsedAssemblyOptions {
    options: Option[];
    assemblyOptions: ParsedAssemblyOptionsMeta;
}
interface TransformAssemblyOptionsArgs {
    assemblyOptionsItems?: Record<GroupId, ProductTypes.AssemblyOptionItem[]>;
    inputValues?: Record<GroupId, InputValue>;
    parentPrice: number;
    parentQuantity: number;
}
export declare function sumAssembliesPrice(assemblyOptions: Record<GroupId, ProductTypes.AssemblyOptionItem[]>): number;
export declare function transformAssemblyOptions({ assemblyOptionsItems, inputValues, parentPrice, parentQuantity, }: TransformAssemblyOptionsArgs): ParsedAssemblyOptions;
export {};
